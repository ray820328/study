Eclipse 平台进行 C/C++ 开发
https://www.ibm.com/developerworks/cn/linux/opensource/os-ecc/index.html
gcc 生成 .a静态库和 .so动态库 
http://www.cppblog.com/wc250en007/archive/2012/11/03/194186.html

静态代码分析工具Coverity
https://blog.csdn.net/yasi_xi/article/details/8349985

c++框架
https://cloud.tencent.com/developer/news/376747

vtune分析消耗热点
Lars 是一个简单、易用、高性能的服务间远程调用管理、调度、负载均衡系统。

C++ new 的基本和高级用法
https://blog.csdn.net/xiaorenwuzyh/article/details/44514815

建议27：区分内存分配的方式
http://book.51cto.com/art/201202/317619.htm

Effective Modern C++
https://proquest.safaribooksonline.com/book/programming/cplusplus/9781491908419

崩溃处理过程
一，strace 查信号描述
strace -i -x -o segfault.txt ./segfault.o
得到如下信息： 
1.错误信号：SIGSEGV 
3.错误码：SEGV_MAPERR 
3.错误内存地址：0x0 
4.逻辑地址0x400507处出错.
二，dmesg 查错误现场
dmesg
得到： 
1.错误类型：segfault ,即段错误（Segmentation Fault）. 
2.出错时ip：0x400507 
3.错误号：6，即110
三，core dump调试
core dump配置：ulimit -c或ulimit -a为0则默认关闭，
$ulimit -c unlimited　　（只对当前shell进程有效）
或在~/.bashrc　的最后加入： ulimit -c unlimited （一劳永逸）

gdb ./test test.core
gdb>bt
出错的代码位置
gdb>print 变量名

https://blog.csdn.net/swartz_lubel/article/details/77972384
i r epb
打印寄存器 ebp 的内容（函数的地址及局部变量栈顶head指针，在 64 位系统中, 寄存器 esp 变成了 rsp, 寄存器 ebp 变成了 rbp, 寄存器 ip 变成了 rip. 而在 arm 平台中, 寄存器 ebp 则变成了 fp）
x /4x 0x...
寄存器 ebp 内容所指向的区域信息
info symbol 0x...
与 head 节点一样, 第一个节点的最低 4 个字节存储的是下一链表节点位置的指针, 紧随其后的 4 个字节是该层调用的返回地址, 查看其内容如下:

http://valgrind.org/downloads/current.html
./configure
make
make install
安装成功后，使用类似如下命令启动程序：
valgrind --tool=memcheck --leak-check=full --track-origins=yes --leak-resolution=high --show-reachable=yes --log-file=memchecklog ./controller_test
其中，–log-file=memchecklog指记录日志文件，名字为memchecklog；–tool=memcheck和–leak-check=full用于内存检测。

STL中的容器注意：
分为顺序存储(如vector、deque)与链式存储(如list、map、set)
链式存储删除
for(; iter!=mapStudent.end(); )
    mapStudent.erase(iter++);
mapStudent.erase(iter++)语句，map中在删除iter的时候，先将iter做缓存，然后执行iter++使之指向下一个结点，再进入erase函数体中执行删除操作，
删除时使用的iter就是缓存下来的iter(也就是当前iter(做了加操作之后的iter)所指向结点的上一个结点)。
但顺序存储第一种用法却是错误的。因为顺序存储的容器一旦erase时，会涉及到数据移动，
iterator所指的位置还是那个位置，但元素却移动了，iter++之后已不再你想要的元素位置了
对于非结点类，如数组类的容器vector,string,deque，如果erase会返回下个有效的iterator,可以这样处理：
for(vector<int>::iterator iter = m_vector.begin(); iter != m_vector.end();)
    if(flag)
         iter = m_vector.erase(iter);
    else
         ++ iter;

模板参数推断，传递
template <typename T>
class Singleton : private NonCopyable {
    template <typename... TArgs>
    static T* NewInstance(TArgs&&... args) {
        assert(!ms_singleton);
        return new T(std::forward(args...));
    }

std::function
void XXX::Foreach(std::function<void(ConfigXXX* config)> iterFunc)
xxxPtr->Foreach([this](ConfigXXX* config) {

Makefile选项CFLAGS,LDFLAGS,LIBS
CFLAGS 表示用于 C 编译器的选项，
CXXFLAGS 表示用于 C++ 编译器的选项。
这两个变量实际上涵盖了编译和汇编两个步骤。
CFLAGS： 指定头文件（.h文件）的路径，如：CFLAGS=-I/usr/include -I/path/include。同样地，安装一个包时会在安装路径下建立一个include目录，当安装过程中出现问题时，试着把以前安装的包的include目录加入到该变量中来。
LDFLAGS：gcc 等编译器会用到的一些优化参数，也可以在里面指定库文件的位置。用法：LDFLAGS=-L/usr/lib -L/path/to/your/lib。每安装一个包都几乎一定的会在安装目录里建立一个lib目录。如果明明安装了某个包，而安装另一个包时，它愣是说找不到，可以抒那个包的lib路径加入的LDFALGS中试一下。
LIBS：告诉链接器要链接哪些库文件，如LIBS = -lpthread -liconv
简单地说，LDFLAGS是告诉链接器从哪里寻找库文件，而LIBS是告诉链接器要链接哪些库文件。不过使用时链接阶段这两个参数都会加上，所以你即使将这两个的值互换，也没有问题。
有时候LDFLAGS指定-L虽然能让链接器找到库进行链接，但是运行时链接器却找不到这个库，如果要让软件运行时库文件的路径也得到扩展，那么我们需要增加这两个库给"-Wl,R"：
LDFLAGS = -L/var/xxx/lib -L/opt/mysql/lib -Wl,R/var/xxx/lib -Wl,R/opt/mysql/lib
如果在执行./configure以前设置环境变量export LDFLAGS="-L/var/xxx/lib -L/opt/mysql/lib -Wl,R/var/xxx/lib -Wl,R/opt/mysql/lib" ，注意设置环境变量等号两边不可以有空格，而且要加上引号（shell的用法）。
那么执行configure以后，Makefile将会设置这个选项，链接时会有这个参数，编译出来的可执行程序的库文件搜索路径就得到扩展了

cJSON不是线程安全的。
但是，在以下情况下它是线程安全的：
永远不使用cJSON_GetErrorPtr（可以使用cJSON_ParseWithOpts的return_parse_end参数）
在任何线程中使用cJSON之前调用cJSON_InitHooks。
在返回对cJSON函数的所有调用之前，永远不会调用setlocale。

字节对齐的规则总结
https://blog.csdn.net/gaoyi221119/article/details/77989522

类型对齐方式（变量存放的起始地址相对于结构的起始地址的偏移量） 
Char 偏移量必须为sizeof(char)即1的倍数 
int 偏移量必须为sizeof(int)即4的倍数 
float 偏移量必须为sizeof(float)即4的倍数 
double 偏移量必须为sizeof(double)即8的倍数 
Short 偏移量必须为sizeof(short)即2的倍数

各成员变量在存放的时候根据在结构中出现的顺序依次申请空间，同时按照上面的对齐方式调整位置，空缺的字节VC会自动填充。
同时VC为了确保结构的大小为结构的字节边界数（即该结构中占用最大空间的类型所占用的字节数）的倍数，所以在为最后一个成员变量申请空间后，
还会根据需要自动填充空缺的字节。
struct MyStruct
{
  char dda; //偏移量为0，满足对齐方式，dda占用1个字节；
  double dda1;//下一个可用的地址的偏移量为1，不是sizeof(double)=8的倍数，需要补足7个字节才能使偏移量变为8（满足对齐方式），因此VC自动填充7个字节，
  //dda1存放在偏移量为8的地址上，它占用8个字节。
  int type； //下一个可用的地址的偏移量为16，是sizeof(int)=4的倍数，满足int的对齐方式，所以不需要VC自动填充，type存放在偏移量为16的地址上，
  它占用4个字节。
}；
//所有成员变量都分配了空间，空间总的大小为1+7+8+4=20，不是结构的节边界数（即结构中占用最大空间的类型所占用的字节数sizeof(double)=8）的倍数，
所以需要填充4个字节，以满足结构的大小为sizeof(double)=8的倍数。所以该结构总的大小为：sizeof(MyStruc)为1+7+8+4+4=24。其中总的有7+4=11个字节是VC自动填充的，没有放任何有意义的东西。
