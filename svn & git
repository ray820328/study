执行sqlite3 .svn/wc.db "select * from work_queue"
看到work_queue中保存的工作队列
执行sqlite3 .svn/wc.db "delete from work_queue" 删除工作队列

svn st | grep '^\?' | tr '^\?' ' ' | sed 's/[ ]*//' | sed 's/[ ]/\\ /g' | xargs svn add
svn st | awk '{if ( $1 == "?") { print $2}}' | xargs svn add
将同一目录下的未加入版本库的文件提交到版本库。 
svn add *
上面只是针对同一目录的文件，如果目录下还有目录，这时上面的命令提交就不行了。如果是二级目录的话。操作命令如下： 
svn add */* 
三目录依次类推。 
svn add */*/* 
svn commit path path path -m ""

git eclipse 冲突解决方法
http://blog.csdn.net/rosten/article/details/17068285

clone失败，更改本地凭证
ssh-keygen -t rsa -C 'Ray820328@163.com'
id_rsa.pub
控制面板\用户帐户\凭据管理器\Windows 凭据
清除账号信息
git config --system --unset credential.helper

git全局ignore文件 + 项目ignore
gitignore_global.txt

git config --global user.name username
git config --global user.email email
git config --list

查看远程是否有提交
git fetch
git status -uno
git show-branch *master
changed=0
git remote update && git status -uno | grep -q 'Your branch is behind' && changed=1
if [ $changed = 1 ]; then
    git pull
    echo "Updated successfully";
else
    echo "Up-to-date"
fi

本地和远程hash
git log --pretty=%H ...refs/heads/master^
git ls-remote origin -h refs/heads/master |cut -f1

git rev-list HEAD...origin/master --count
if git checkout master &&
    git fetch origin master &&
    [ `git rev-list HEAD...origin/master --count` != 0 ] &&
    git merge origin/master
then
    echo 'Updated!'
else
    echo 'Not updated.'
fi

【python3】
#strCommand = r'd: && cd {} && git rev-list {}...{} --count'
strCommand = r'cd {} && git rev-list {}...{} --count'
'''Execute commant, return string array.'''
execCommand = strCommand.format(localDir, "HEAD", "origin/master")
#output = os.system(execCommand)
#execCommand = ["git", "rev-list", "HEAD...origin/master", "--count"]
result = run(execCommand, stdout=PIPE, stderr=PIPE, universal_newlines=True, shell=True)
print("status = %s, output = %s" % (result.stderr, result.stdout))
if result.stderr.strip() != "":
   assert False
if result.stdout.strip() != "0":

@echo off
::    
:: Stops commits that have empty log messages.
::

@echo off

set svnlook="svnlook.exe"
setlocal

rem Subversion sends through the path to the repository and transaction id
set REPOS=%1
set TXN=%2

rem check for an empty log message
%svnlook% log %REPOS% -t %TXN% | findstr . > nul
if %errorlevel% gtr 0 (goto err) else exit 0

:err
echo. 1>&2
echo 请填写相关问题ID到修改日志，谢谢！ 1>&2
exit 1

git add . 
git add xx命令可以将xx文件添加到暂存区，如果有很多改动可以通过 git add -A .来一次添加所有改变的文件。注意 -A 选项后面还有一个句点。 git add -A表示添加所有内容， git add . 表示添加新文件和编辑过的文件不包括删除的文件; git add -u 表示添加编辑或者删除的文件，不包括新添加的文件
git commit -m "comment"
git pull [远程主机名] [远程分支名]:[本地分支名] --rebase origin master
git push [远程主机名] [本地分支名]:[远程分支名] -u origin master
git fetch [远程主机名] [分支名]
git checkout -m 版本号 文件/文件夹
git branch -r/-a --来查看远程分支
$ git merge origin/master
# 或者在本地分支上合并远程分支
$ git rebase origin/master
第一种方法
   git fetch --all
   git reset --hard origin/master
   git fetch  下载远程最新的。
   git reset master  分支重置
第二种方法
   git reset --hard HEAD
   git pull
#本地分支和远程分支建立映射关系的作用
git branch --set-upstream-to origin/远程分支名  本地分支名
#拉取分支
git pull
拉取远程分支并创建本地分支
git checkout -b 本地分支名x origin/远程分支名x
使用该方式会在本地新建分支x，并自动切换到该本地分支x。
采用此种方法建立的本地分支会和远程分支建立映射关系。
git fetch origin 远程分支名x:本地分支名x
使用该方式会在本地新建分支x，但是不会自动切换到该本地分支x，需要手动checkout。
采用此种方法建立的本地分支不会和远程分支建立映射关系。
切换分支
git checkout 本地分支名
合并分支
git merge 本地分支名称
建立远程分支
git push origin cola_build:远端分支名
远程分支Chapater6
使用命令 git push origin --delete cola_build
删除本地分支
git branch -d 本地分支名称

保留生产服务器上所做的改动,仅并入新配置项
git stash
git pull
git stash pop
可以使用git diff -w +文件名 来确认代码自动合并的情况

代码库中的文件完全覆盖本地工作版本
git reset --hard
git pull
针对文件回退本地修改
git checkout HEAD file/to/restore

工作区和暂存区的区别 git diff
工作区和版本库的区别 git diff HEAD
暂存区和版本库的区别 git diff --cached
git log --oneline --graph
merge git reset --merge 7f811bf 或 git reset --merge HEAD^
git clean -f
---------------------------

git 拉取远程分支到本地
1、新建一个空目录，进入目录
2、初始化
git init
3、自己要与origin master建立连接（下划线为远程仓库链接）
git remote add origin https://github.com/ray820328/study.git
4、把远程分支拉到本地
git fetch origin develop（develop为远程仓库的分支名）
5、在本地创建分支dev并切换到该分支
git checkout -b dev(本地分支名称) origin/develop(远程分支名称)
6、把某个分支上的内容都拉取到本地
git pull origin develop(远程分支名称)
7、获取子模块
git submodule update --init --recursive
----------------------------

git合并分支，解决冲突
1，先检出项目到一个文件夹
git clone

2，你检出的项目默认是master，所以现在要查看远程全部分支
git branch -a
* master
  remotes/origin/HEAD -> origin/master
  remotes/origin/v1.2
  remotes/origin/master
  remotes/origin/v1.1
  remotes/origin/v1.0

3，切换分支
比如同时有三个人开发，1.2最早是基于1.0，但是由于项目未发布，1.0,1.1,1.2全部都在同时开发，现在想把1.0已经增加的功能先合并到1.2；
此时的步骤：check 1.2和1.0
git checkout v1.0 
git checkout v1.2

然后再v1.2的分支基础上执行merge
git merge v1.0

如果没有报错，那就直接提交代码git push origin v1.2
如果报错，基本是冲突了(比如)：
CONFLICT (content): Merge conflict in app/src/main/AndroidManifest.xml
Auto-merging app/build.gradle
CONFLICT (content): Merge conflict in app/build.gradle
Automatic merge failed; fix conflicts and then commit the result.
你需要去到提示的文件里把git自动标注的版本冲突注释掉，看你具体需要的功能进行删减

然后把冲突的文件git add，和commit 
比如有2个冲突文件，多文件add的时候直接空格隔开
git add app/src/main/AndroidManifest.xml app/build.gradle
最后再commit
git commit -m "解决2个分支之间的冲突"

4，提交代码
git push origin v1.2

5，参考命令：
Git鼓励大量使用分支：
查看分支：git branch
创建分支：git branch <name>
切换分支：git checkout <name>
创建+切换分支：git checkout -b <name>
合并某分支到当前分支：git merge <name>
删除分支：git branch -d <name>

git restore -s HEAD~1 READEME.md  // 将版本回退到当前快照的前一个版本
git restore -s 91410eb9  READEME.md  // 指定明确的 commit id ，回退到指定的快照中
git reset --soft HEAD^  // 撤销 commit 至上一次 commit 的版本
git restore --worktree README.md	表示撤销 README.md 文件工作区的的修改	参数等同于 -W
git restore --staged README.md	表示撤销暂存区的修改，将文件状态恢复到未 add 之前	参数等同于 -S

在develop分支上rebase另外一个分支master，是将master作为本地，develop作为远端来处理的。
最后的效果是，develop分支看起来像是在master分支的最新的节点之后才进行开发的
C1<--C2<--C3<--C6<--C7      master分支
            <--C4<--C5      develop分支
1.首先切换到develop分支  
git checkout develop
2.在develop分支上进行rebase    
git rebase master
【rebase是在master分支的最后一个提交C7上开始的】
将C4和C7合并，得到一个合并结果result1
再将C5和result1合并，得到一个合并结果result2
C4和C7合并的时候产生冲突，Local是C7，C5作为Remote出现
在develop分支上rebase另外一个分支master，是将master作为本地，develop作为远端来处理的

对于merge的分支，如果要revert的话，需要制定回滚到哪个版本，因为merge设计到了两个版本： 
如：
Merge branch 'rms-develop' into master
git revert 版本id -m 1
git reset --hard commitId
这个1 指的是master，2指的是develop。现在是在master分支上回滚 develop合并到master上的部分代码。 
       这种方式，是用一种反向的push来重新提交一次。git中可以看到操作记录
看似达到的效果是一样的,其实完全不同. 
第一: 
       上面我们说的如果你已经push到线上代码库, reset 删除指定commit以后,你git push可能导致一大堆冲突.但是revert 并不会. 
第二: 
       如果在日后现有分支和历史分支需要合并的时候,reset 恢复部分的代码依然会出现在历史分支里.但是revert 方向提交的commit 并不会出现在历史分支里. 
第三: 
       reset 是在正常的commit历史中,删除了指定的commit,这时 HEAD 是向后移动了,而 revert 是在正常的commit历史中再commit一次,只不过是反向提交,他的 HEAD 是一直向前的.

删除 一些 没有 git add 的 文件；
git clean -d -fx
    -n 显示将要删除的文件和目录；
    -x -----删除忽略文件已经对git来说不识别的文件
    -d -----删除未被添加到git的路径中的文件
    -f -----强制运行

git revert和git reset的区别
revert 是将之前的提交反转（新增就删除），然后作为一次新的提交；
reset commit_id是回滚到该commit_id下，该commit_id之后的提交都会删除。
在生产环境一般建议用git revert。
步入正题：(若回滚多个commit，做好先回滚最近的commit) 
1、git revert -n commit_id ，若出现is a merge but no -m option was given 
这是因为你revert的那个commit是一个merge commit，它有两个parent, Git不知道base是选哪个parent，就没法diff，要显示告诉Git用哪一个parent。 
git revert -n commit_id -m 1 这样就选parent 1，那么parent 1又是哪一个呢？ 
一般来说，如果你在master上merge branch_xxx,那么parent 1就是master，parent 2就是branch_xxx. 
2、git reset HEAD 
3、git add. 
4、git commit -m “xxx” 
5、git push origin master
revert之后，修改好分支再merge到master发现之前merge的代码不能merge到master上了，这是因为master上已经有了之前的merge历史了 
解决办法：revert之前revert的commit_id 

--------------------- 

mac免密码git
在~/下， touch创建文件 .git-credentials：
touch .git-credentials
# 用vim编辑此文件，
vim .git-credentials
#输入内容格式
https://username:password@github.com
git config --global credential.helper store
可以看到~/.gitconfig文件，会多了一项：
[credential]
    helper = store
删除保存的密码
git credential-osxkeychain erase
https://my.oschina.net/yangq20/blog/803036
https://www.cnblogs.com/SUPER-F/p/7298556.html
