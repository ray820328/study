《Linux内核设计与实现》
《深入理解Linux内核》
《深入理解Linux虚拟内存管理》
《深入理解LINUX网络内幕》

共享内存（上）
https://www.ibm.com/developerworks/cn/linux/l-ipc/part5/index1.html

perf、 gprof 等程序的性能分析工具
性能分析工具几个因素： 
工具本身消耗的cpu大小：valgrind本身cpu消耗非常大，不适合使用于服务器负载较大时的性能分析，只适合于性能是线性增长的情况并作低负载测试。Oprofile、perf等系统内核支持的一般cpu消耗较低。 
能否用于运营环境的性能分析：Gprof是使用编译时嵌入代码的方式，需要程序正常退出才能得到统计结果，oprofile需要重编系统内核支持，运营环境下使用不方便。 
可视化操作是否简便等
基于功能上考虑。Gprof不能统计内核调用消耗，perf、vtune等基于硬件性能计数器的方式可以提供多种事件的统计分析结果，
perf工具指定branch-misses事件查看函数的分支预测失败率并进行优化

linux 下/proc/self/statm有当前进程的内存占用情况，
共有七项：vsize虚拟内存页数、resident物理内存、share共享内存、text代码段内存页数， lib引用库内存页数、data_stack 数据/堆栈段内存页数、dt 脏页数，
单位是内存的页数，需要乘以getpagesize()转换为byte。在每个模块结束后统计vsize的增加，可知该模块占用的内存大小

这并不是说“STL必然是坏的”, 编写一个在非优化的build模式下不会变慢10倍的STL实现是有可能的（如EASTL或Libc++）。但是无论出于何种原因，微软的STL速度非常慢。由于它过度依赖于inlining.
作为语言的使用者，我不在乎它是谁的错！我只知道的“STL在调试中太慢”，我要么将它解决掉，要么寻找替代方案（例如不使用STL，重新实现我需要的bits库，或者完全不再使用C++）。

Linux内存管理
sbrk不是系统调用，是C库函数。系统调用通常提供一种最小功能，而库函数通常提供比较复杂的功能。
在Linux系统上，程序被载入内存时，内核为用户进程地址空间建立了代码段、数据段和堆栈段，在数据段与堆栈段之间的空闲区域用于动态内存分配。
内核数据结构mm_struct中的成员变量start_code和end_code是进程代码段的起始和终止地址，start_data和 end_data是进程数据段的起始和终止地址，start_stack是进程堆栈段起始地址，start_brk是进程动态内存分配起始地址（堆的起始地址），还有一个 brk（堆的当前最后地址），就是动态内存分配当前的终止地址。
C语言的动态内存分配基本函数是malloc()，在Linux上的基本实现是通过内核的brk系统调用。brk()是一个非常简单的系统调用，只是简单地改变mm_struct结构的成员变量brk的值。
mmap系统调用实现了更有用的动态内存分配功能，可以将一个磁盘文件的全部或部分内容映射到用户空间中，进程读写文件的操作变成了读写内存的操作。在 linux/mm/mmap.c文件的do_mmap_pgoff()函数，是mmap系统调用实现的核心。do_mmap_pgoff()的代码，只是新建了一个vm_area_struct结构，并把file结构的参数赋值给其成员变量m_file，并没有把文件内容实际装入内存。
Linux内存管理的基本思想之一，是只有在真正访问一个地址的时候才建立这个地址的物理映射。
C语言跟内存分配方式
（1） 从静态存储区域分配。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量，static变量。
（2） 在栈上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运
算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。
（3）从堆上分配，亦称动态内存分配。程序在运行的时候用malloc或new申请任意多少的内存，程序员自己负责在何时用free或delete释放内存。动态内存的生存期由我们决定，使用非常灵活，但问题也最多
C语言跟内存申请相关的函数主要有 alloc,calloc,malloc,free,realloc,sbrk等.其中alloc是向栈申请内存,因此无需释放. malloc分配的内存是位于堆中的,并且没有初始化内存的内容,因此基本上malloc之后,调用函数memset来初始化这部分的内存空间.calloc则将初始化这部分的内存,设置为0. 而realloc则对malloc申请的内存进行大小的调整.申请的内存最终需要通过函数free来释放. 而sbrk则是增加数据段的大小;
malloc/calloc/free基本上都是C函数库实现的,跟OS无关.C函数库内部通过一定的结构来保存当前有多少可用内存.如果程序 malloc的大小超出了库里所留存的空间,那么将首先调用brk系统调用来增加可用空间,然后再分配空间.free时,释放的内存并不立即返回给os, 而是保留在内部结构中. 可以打个比方: brk类似于批发,一次性的向OS申请大的内存,而malloc等函数则类似于零售,满足程序运行时的要求.这套机制类似于缓冲.
使用这套机制的原因: 系统调用不能支持任意大小的内存分配(有的系统调用只支持固定大小以及其倍数的内存申请,这样的话,对于小内存的分配会造成浪费; 系统调用申请内存代价昂贵,涉及到用户态和核心态的转换.
函数malloc()和calloc()都可以用来分配动态内存空间，但两者稍有区别。   
     malloc()函数有一个参数，即要分配的内存空间的大小：    
     void *malloc(size_t size); 
     calloc()函数有两个参数，分别为元素的数目和每个元素的大小，这两个参数的乘积就是要分配的内存空间的大小：   
     void *calloc(size_t numElements，size_t sizeOfElement)；
     如果调用成功，函数malloc()和calloc()都将返回所分配的内存空间的首地址。
     malloc() 函数和calloc()函数的主要区别是前者不能初始化所分配的内存空间，而后者能。如果由malloc()函数分配的内存空间原来没有被使用过，则其中的每一位可能都是0；反之，如果这部分内存空间曾经被分配、释放和重新分配，则其中可能遗留各种各样的数据。也就是说，使用malloc()函数的程序开始时(内存空间还没有被重新分配)能正常运行，但经过一段时间后(内存空间已被重新分配)可能会出现问题。
     calloc() 函数会将所分配的内存空间中的每一位都初始化为零，也就是说，如果你是为字符类型或整数类型的元素分配内存，那么这些元素将保证会被初始化为零；如果你是为指针类型的元素分配内存，那么这些元素通常(但无法保证)会被初始化为空指针；如果你是为实数类型的元素分配内存，那么这些元素可能(只在某些计算机中)会被初始化为浮点型的零。

Linux Kernel 的 TCP/IP 协议栈提供了一组控制参数用于配置 TCP 端口 的快速回收重用，当把它们的值设置为1时表示启用该选项： 
1) net.ipv4.tcp_tw_reuse = 1 
2) net.ipv4.tcp_tw_recycle = 1 
3) net.ipv4.tcp_timestamps = 1（tcp_tw_recycle启用时必须同时启用本项， 反之则不然，timestamps 用于 RTT 计算，在 TCP 报文头部的可选项中传输，两个参数分别为发送方发送TCP报文时的时间戳和接收方收到TCP报文 响应时的时间戳。Linux系统和移动设备上的Android、iOS都缺省开启了此选 项，建议不要随意关闭） 
 


