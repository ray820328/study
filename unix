版本信息
lsb_release -a
cat /proc/version
centos cat /etc/redhat-release

挂载硬盘
fdisk -l
fdisk /dev/vdb
n->p->1->回车->回车【意思就是新建一个主分区，大小是整个sdd磁盘】
最后执行w，写入磁盘
mkfs.ext4 /dev/vdb
mkdir /disk1
mount /dev/vdb /disk1

zip -r wwwroot.zip wwwroot
磁盘大小
df -h

防火墙
service iptables stop
iptables -V
/etc/init.d/iptables status
vi /etc/sysconfig/iptables 
-A INPUT -m state --state NEW -m tcp -p tcp --dport 22 -j ACCEPT
永久性关闭防火墙 
chkconfig --level 35 iptables off /etc/init.d/iptables stop iptables

chkconfig iptables --list
chkconfig iptables off

为了不重启服务器而使配置立即生效，可以执行
　　#sysctl -w net.ipv4.tcp_max_syn_backlog=2048
　　#sysctl -w net.ipv4.tcp_syncookies=1
　　#sysctl -w net.ipv4.tcp_synack_retries=3
　　#sysctl -w net.ipv4.tcp_syn_retries=3
　　也有的人喜欢用访问控制列表来防止SYN的攻击，在一定程度上减缓了syn的攻击，防Syn 洪水攻击
　　-A INPUT -p tcp --syn -m limit --limit 1/s -j ACCEPT
　　--limit 1/s 限制syn并发数每秒1次
　　防端口扫描
　　-A FORWARD -p tcp --tcp-flags SYN,ACK,FIN,RST RST -m limit --limit 1/s -j ACCEPT
　　死亡之ping
　　-A FORWARD -p icmp --icmp-type echo-request -m limit --limit 1/s -j ACCEPT

字符编码
/etc/sysconfig/i18n
原来的配置：
LANG="C"
SYSFONT="latarcyrheb-sun16"
现在的配置：LANG="zh_CN.UTF-8"
SYSFONT="latarcyrheb-sun16"
source /etc/sysconfig/i18n

export LC_ALL=zh_CN.en_US.UTF-8 
source /etc/profile

查看端口被占用的详细信息
netstat -lnput | grep 80
#ps -aux | grep 17599

系统设置，如打开文件数
ulimit -a
open files 打开的文件句柄数
max user processes 用户最大运行进程数

对于服务器可以采用如下方法修改file-max:
（1）重启机器后恢复为默认值
echo 100000 > /proc/sys/fs/file-max
或者
sysctl -w "fs.file-max=100000"
（2）修改配置文件/etc/sysctl.conf, 在最后加上一行：
fs.file-max = 100000
然后重启机器后生效。以后永久生效。

打开的连接数fd
netstat -ano|grep 80|grep -V EST|wc -l
netstat -ano|grep 80|grep -V EST|less

建立软连接
ln -s file1 file1soft
rm -rf file1soft

端口服务状态查看
netstat – ano

编辑网卡配置文件，命令： vim /etc/sysconfig/network-scripts/ifcfg-eth0
DEVICE=eth0
HWADDR=44:8A:5B:7D:2F:4A
TYPE=Ethernet
UUID=2ba3d053-88f3-41b3-a3ea-66c5c8e7f248
ONBOOT=yes
NM_CONTROLLED=no
#BOOTPROTO=dhcp
IPADDR=10.10.84.16
NETMASK=255.255.255.0
GATEWAY=10.10.84.254
DNS1=202.96.128.86
DNS2=210.21.196.6

重启网络连接，命令： service network restart

------------------------------ssh免密码登录---------------------------------
先确保所有主机的防火墙处于关闭状态。
----------------
如果没有ssh，先安装，
which ssh
#rpm -qa |grep ssh 检查是否装了SSH包
没有的话yum install openssh-server和yum install openssh-clients
#chkconfig --list sshd 检查SSHD是否在本运行级别下设置为开机启动
#chkconfig --level 2345 sshd on如果没设置启动就设置下.
#service sshd restart重新启动
#netstat -antp |grep sshd看是否启动了22端口.确认下.
#iptables -nL看看是否放行了22口.
----------------
在主机A上执行如下：
　1.　$cd ~/.ssh
　2.　$ssh-keygen -t rsa  --------------------然后一直按回车键，就会按照默认的选项将生成的密钥保存在.ssh/id_rsa文件中。
　3.　$cp id_rsa.pub authorized_keys 
         这步完成后，正常情况下就可以无密码登录本机了，即ssh localhost，无需输入密码。
　4.　$scp authorized_keys summer@10.0.5.198:/home/summer/.ssh   ------把刚刚产生的authorized_keys文件拷一份到主机B上.　　
　5.　$chmod 600 authorized_keys       
　　   进入主机B的.ssh目录，改变authorized_keys文件的许可权限。
　　 (4和5可以合成一步，执行:  $ssh-copy-id -i root@192.168.201.102)
默认用法：
ssh-copy-id user@server  
自定义用法：
ssh-copy-id -i 公钥文件路径 user@server
ssh-copy-id -p 服务器SSH服务端口 user@server

------------------------------Yum(未成功)---------------------------------
CentOS下重新安装yum (2013-02-17 22:14:55)转载▼
标签： linux centos 安装yum yum	分类： Linux
1，下载最新的yum-3.2.28.tar.gz并解压
#wget http://yum.baseurl.org/download/3.2/yum-3.2.28.tar.gz
#tar xvf yum-3.2.28.tar.gz
2，进入目录，运行安装
#cd yum-3.2.28
#./yummain.py install yum
如果提示错误： CRITICAL:yum.cli:Config Error: Error accessing file for config file:///etc/
是缺少配置文件。在etc目录下面新建yum.conf文件，然后再次运行 yummain.py install yum，顺利完成安装。
3，最后更新系统
#yum check-update
#yum update
#yum clean all

---------------------------------Python2.7------------------------------
centos6安装python2.7
tar zxvf Python-2.7.9.tgz
./configure
make
make install

mv /usr/bin/python /usr/bin/python2.6
千万不要做，否则yum以及其他一些依赖python的环境会失效
ln -s /usr/local/bin/python2.7 /usr/bin/python2.6
/usr/bin/python -V

---------------------------------JDK------------------------------
rpm -qa | grep jdk
jdk-1.6.0_45-fcs.x86_64
rpm -qa | grep gcj
libgcj-4.4.7-4.el6.x86_64
java-1.5.0-gcj-1.5.0.0-29.1.el6.x86_64

rpm -e --nodeps jdk-1.6.0_45-fcs.x86_64
rpm -e --nodeps libgcj-4.4.7-4.el6.x86_64
rpm -e --nodeps java-1.5.0-gcj-1.5.0.0-29.1.el6.x86_64

rpm -ivh --replacepkgs jdk-7u79-linux-x64.rpm
# chmod +x jre-7u79-linux-x64-rpm.bin （对 .bin 文件加上可执行权限）
# ./jre-7u79-linux-x64-rpm.bin

设置环境变量
在/etc/profile文件末尾处追加下面信息：
export JAVA_HOME=/usr/java/jdk1.7.0_79
export CLASSPATH=.:$JAVA_HOME/jre/lib/rt.jar:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar
export PATH=$PATH:$JAVA_HOME/bin
刷新环境变量（执行下面命令）
# source /etc/profile

------------------------------ZooKeeper---------------------------------
# tar zxf zookeeper-3.3.3.tar.gz
# cp -R zookeeper-3.3.3 /usr/local/zookeeper
# vi ~/.bashrc (设置ZOOKEEPER_HOME和ZOOKEEPER_HOME/bin) 
          追加：
          export ZOOKEEPER_HOME=/home/data/zookeeper
          export PATH=$PATH:$ZOOKEEPER_HOME/bin

# cp /usr/local/zookeeper/conf/zoo_sample.cfg /usr/local/zookeeper/conf/zoo.cfg (用zoo_sample.cfg制作$ZOOKEEPER_HOME/conf/zoo.cfg)
启动zookeeper：

/usr/local/zookeeper/bin/zkServer.sh start  单机版直接启动，不用修改什么配置，

zkServer.sh status   #查看zkserver是否成功启动
[root@master bin]# ./zkServer.sh status
JMX enabled by default
Using config: /usr/local/zookeeper-3.3.5/bin/../conf/zoo.cfg
Mode: standalone
 输入jps命令查看进程：
namenode上显示为（本次为单机配置）：
19361 QuorumPeerMain
21691 Jps
其中，QuorumPeerMain是zookeeper进程，启动正常。

tickTime=2000
dataDir=/var/zookeeper/
clientPort=2181
initLimit=5
syncLimit=2
server.1=zoo1:2888:3888
server.2=zoo2:2888:3888
server.3=zoo3:2888:3888


-----------------------------文件输出命令----------------------------

“>/dev/null 2>&1”  拆为四部分来分析下:
1：> 代表重定向到哪里，例如：echo "123" > /home/123.txt
2：首先 0> 表示stdin标准输入; 1> 表示stdout标准输出; 2> 表示stderr错误输出; 
3：/dev/null 代表空设备文件
4：& 可以理解为是"等同于"的意思，2>&1，即表示2的输出重定向等同于1
5：1 表示stdout标准输出，系统默认值是1，所以">/dev/null"等同于 "1>/dev/null"
因此，>/dev/null 2>&1 也可以写成“1> /dev/null 2> &1”
那么'>/dev/null 2>&1'执行过程为：
1>/dev/null ：首先表示标准输出重定向到空设备文件，也就是不输出任何信息到终端，说白了就是不显示任何信息。
2>&1 ：接着，将标准错误输出重定向 到 标准输出，
因为之前标准输出已经重定向到了空设备文件，所以标准错误输出也重定向到空设备文件。
最常用方式：
command > file 2>file与command > file 2>&1
区别在哪里？
首先，command > file 2>file 的意思是将命令所产生的标准输出信息，和错误的输出信息送到file 中.
command > file 2>file 这样的写法，stdout和stderr都直接送到file中， 
file会被打开两次，这样stdout和stderr会互相覆盖，这样写相当使用了FD1和FD2两个同时去抢占file 的管道。
而command >file 2>&1 这条命令就将stdout直接送向file， stderr 继承了FD1管道后，再被送往file，
此时file只被打开了一次，也只使用了一个管道FD1，它包括了stdout和stderr的内容。
从IO效率上，前一条命令的效率要比后面一条的命令效率要低，
所以在编写shell脚本的时候，很多时候会command > file 2>&1 这样的写法。

---------------------------------------------------------------

VMWare centos6 桥接模式网络设置

1、禁用网络管理器
# chkconfig NetworkManager off
# service  NetworkManager stop
2、创建用以桥接的虚拟网卡

# cd /etc/sysconfig/network-scripts 
# cp ifcfg-eth0 ifcfg-br0
3、编辑 ifcfg-br0
# vi ifcfg-br0 

DEVICE=br0
TYPE="Bridge"
ONBOOT="yes"
BOOTPROTO=static
IPADDR=10.10.87.251
PREFIX=24
GATEWAY=10.10.87.254
DNS1=223.5.5.5
DNS2=180.76.76.76

DELAY=0

4、编辑ifcfg-eth0

# vi ifcfg-eth0 

DEVICE=eth0
NM_CONTROLLED="yes"
ONBOOT=yes
TYPE=Ethernet
BRIDGE=br0
BOOTPROTO=none
IPADDR=10.10.87.251
PREFIX=24
GATEWAY=10.10.87.254
DEFROUTE=yes
IPV4_FAILURE_FATAL=yes
IPV6INIT=no
NAME="System eth0"
UUID=3fc763c1-7c6d-4239-9f60-76b1659bfcd1
DNS1=223.5.5.5
DNS2=180.76.76.76
HWADDR=00:0C:29:DE:BF:0D

IPADDR：和你的电脑同一网段的IP地址
GATEWAY：与你的电脑的默认网关相同
5、重新启动网络

# service network restart
6、可能提示以下错误：
Bringing up interface eth0: Device eth0 does not seem to be present,delaying initialization. [FAILED]

解决办法：

首先，打开/etc/udev/rules.d/70-persistent-net.rules内容如下面例子所示：

# vi /etc/udev/rules.d/70-persistent-net.rules
# This file was automatically generated by the /lib/udev/write_net_rules
# program, run by the persistent-net-generator.rules rules file.
#
# You can modify it, as long as you keep each rule on a single
# line, and change only the value of the NAME= key.
# PCI device 0x1022:0x2000 (pcnet32)
SUBSYSTEM=="net", ACTION=="add", DRIVERS=="?*", ATTR{address}=="00:0c:29:8f:89:9
7", ATTR{type}=="1", KERNEL=="eth*", NAME="eth0"
# PCI device 0x1022:0x2000 (pcnet32)
SUBSYSTEM=="net", ACTION=="add", DRIVERS=="?*", ATTR{address}=="00:0c:29:50:bd:1
7", ATTR{type}=="1", KERNEL=="eth*", NAME="eth1"
记录下，eth1网卡的mac地址00:0c:29:50:bd:17
接下来，打开/etc/sysconfig/network-scripts/ifcfg-eth0
# vi /etc/sysconfig/network-scripts/ifcfg-eth0

将 DEVICE="eth0" 改成 DEVICE="eth1" ,
将 HWADDR="00:0c:29:8f:89:97" 改成上面的mac地址 HWADDR="00:0c:29:50:bd:17"

最后，重启网络

# service network restart
或者

# /etc/init.d/network restart

---------------------------------------------------------------

