/etc/init.d/mysqld start/stop

set character_set_connection = 'utf8';
set character_set_results = 'utf8';
set character_set_client = 'utf8';
set names gbk

--------------------------------------centos6安装mysql5.5-----------------------------------
yum list installed | grep -i mysql
yum remove mysql mysql-*
rpm -Uvh http://dl.fedoraproject.org/pub/epel/6/i386/epel-release-6-8.noarch.rpm
rpm -Uvh http://rpms.famillecollet.com/enterprise/remi-release-6.rpm

yum --enablerepo=remi,remi-test install mysql mysql-server

yum list installed | grep -i mysql

/etc/init.d/mysqld start ## use restart after update
OR
service mysqld start ## use restart after update

chkconfig --levels 235 mysqld on

Last
mysql_upgrade -u root -p
Now my MySql version is 5.5.32

-------------------------------------------------------------------------

GRANT ALL PRIVILEGES ON *.* TO root@localhost IDENTIFIED BY 'admin' WITH GRANT OPTION; 
GRANT ALL PRIVILEGES ON *.* TO root@"%" IDENTIFIED BY 'admin' WITH GRANT OPTION;
delete from `mysql`.`user` where user='';
flush privileges;

-------------------------------------------------------------------------
忘记root密码
1、先结束mysqld进程
#killall mysqld

不加载grant_tables而进入mysql
#mysqld_safe --skip-grant-tables &

进入mysql
mysql> use mysql
Database changed

mysql> select * from user;
Empty set (0.00 sec)

mysql> insert into user set user='root',ssl_cipher='',x509_issuer='',x509_subject='';               
(增加root用户的表）
Query OK, 1 row affected, 3 warnings (0.00 sec)
(这时可能会提示某字段如ssl_cipher无默认值,　只要加上,ssl_cipher=''; 其字段如有提示依次添加就OK了)
update user set Host='localhost',select_priv='y', insert_priv='y',update_priv='y', Alter_priv='y',delete_priv='y',create_priv='y',drop_priv='y',reload_priv='y',shutdown_priv='y',Process_priv='y',file_priv='y',grant_priv='y',References_priv='y',index_priv='y',create_user_priv='y',show_db_priv='y',super_priv='y',create_tmp_table_priv='y',Lock_tables_priv='y',execute_priv='y',repl_slave_priv='y',repl_client_priv='y',create_view_priv='y',show_view_priv='y',create_routine_priv='y',alter_routine_priv='y',create_user_priv='y' where user='root';                            
(这里面是修改root用户的权限)
mysql> quit;

2、带权限正常启动mysql
#service mysqld start

-------------------------------------------------------------------------

Mysql5.0以上的版本可以支持将执行比较慢的SQL语句记录下来。
mysql> show variables like 'long%'; 注：这个long_query_time是用来定义慢于多少秒的才算“慢查询”
+-----------------+-----------+
| Variable_name | Value |
+-----------------+-----------+
| long_query_time | 10.000000 |
+-----------------+-----------+
1 row in set (0.00 sec)
mysql> set long_query_time=1; 注： 我设置了1, 也就是执行时间超过1秒的都算慢查询。
Query OK, 0 rows affected (0.00 sec)
mysql> show variables like 'slow%';
+---------------------+---------------+
| Variable_name | Value |
+---------------------+---------------+
| slow_launch_time | 2 |
| slow_query_log | ON | 注：是否打开日志记录
| slow_query_log_file | /tmp/slow.log | 注： 设置到什么位置
+---------------------+---------------+
3 rows in set (0.00 sec)
mysql> set global slow_query_log='ON' 注：打开日志记录
一旦slow_query_log变量被设置为ON，mysql会立即开始记录。
/etc/my.cnf 里面可以设置上面MYSQL全局变量的初始值。
long_query_time=1
slow_query_log_file=/tmp/slow.log


/path/mysqldumpslow -s c -t 10 /tmp/slow-log
这会输出记录次数最多的10条SQL语句，其中：
-s, 是表示按照何种方式排序，c、t、l、r分别是按照记录次数、时间、查询时间、返回的记录数来排序，ac、at、al、ar，表示相应的倒叙；
-t, 是top n的意思，即为返回前面多少条的数据；
-g, 后边可以写一个正则匹配模式，大小写不敏感的；
比如
/path/mysqldumpslow -s r -t 10 /tmp/slow-log
得到返回记录集最多的10个查询。
/path/mysqldumpslow -s t -t 10 -g “left join” /tmp/slow-log
得到按照时间排序的前10条里面含有左连接的查询语句。


init配置慢查询
1、在my.ini配置文件中添加以下选项：

log-slow-queries=master-0-slow.log 慢查询日志位置

log-queries-not-using-indexes=on  没有使用索引的Query也计入慢查询日志

long_query_time=1  当Query语句大于1秒时记入慢查询日志

--> linux下mysql开启慢查询方法:

mysql在linux系统中的配置文件一般是my.cnf,我的路径是/etc/my.cnf,你根据自己编译安装的路径去查找 vi /etc/my.cnf

一样是在[mysqld]下面加上：

log-slow-queries=/var/lib/mysql/slowquery.log

long_query_time=2

log-queries-not-using-indexes

这里就不再解释了,加上后重启mysql,就可以到/var/lib/mysql下看是否有slowquery.log生成了. cd /var/lib/mysql/





mysql 查询语句分析

　一.语法

　　explain < table_name >

　　例如: explain select * from t3 where id=3952602;


　1.我的理解是SQL执行的顺利的标识,SQL从大到小的执行.

　　例如:

    mysql> explain select * from (select * from ( select * from t3 where id=3952602) a) b; 
　　+----+-------------+------------+--------+-------------------+---------+---------+------+------+-------+ 
　　| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra | 
　　+----+-------------+------------+--------+-------------------+---------+---------+------+------+-------+ 
　　| 1 | PRIMARY | | system | NULL | NULL | NULL | NULL | 1 | | 
　　| 2 | DERIVED | | system | NULL | NULL | NULL | NULL | 1 | | 
　　| 3 | DERIVED | t3 | const | PRIMARY,idx_t3_id | PRIMARY | 4 | | 1 | | 
　　+----+-------------+------------+--------+-------------------+---------+---------+------+------+-------+


　　很显然这条SQL是从里向外的执行,就是从id=3 向上执行. 这一点和oracle有些象，就是语句的执行次序。


   2. select_type就是select类型,可以有以下几种

　　(1) SIMPLE

　　简单SELECT(不使用UNION或子查询等) 例如:　


   3.table

　　显示这一行的数据是关于哪张表的.

　　有时不是真实的表名字,看到的是derivedx(x是个数字,我的理解是第几步执行的结果)　

　 4.type

　　这列很重要,显示了连接使用了哪种类别,有无使用索引.

　　从最好到最差的连接类型为const、eq_reg、ref、range、indexhe和ALL

    (1).system

　　这是const联接类型的一个特例。表仅有一行满足条件.如下(t3表上的id是 primary key)

    mysql> explain select * from (select * from t3 where id=3952602) a ; 
　　+----+-------------+------------+--------+-------------------+---------+---------+------+------+-------+ 
　　| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra | 
　　+----+-------------+------------+--------+-------------------+---------+---------+------+------+-------+ 
　　| 1 | PRIMARY | | system | NULL | NULL | NULL | NULL | 1 | | 
　　| 2 | DERIVED | t3 | const | PRIMARY,idx_t3_id | PRIMARY | 4 | | 1 | | 
　　+----+-------------+------------+--------+-------------------+---------+---------+------+------+-------+

　  (2).const

　　表最多有一个匹配行，它将在查询开始时被读取。因为仅有一行，在这行的列值可被优化器剩余部分认为是常数。const表很快，因为它们

只读取一次!

　　const用于用常数值比较PRIMARY KEY或UNIQUE索引的所有部分时。


    (3). eq_ref

　　对于每个来自于前面的表的行组合，从该表中读取一行。这可能是最好的联接类型，除了const类型。它用在一个索引的所有部分被联接使

用并且索引是UNIQUE或PRIMARY KEY。

　　eq_ref可以用于使用= 操作符比较的带索引的列。比较值可以为常量或一个使用在该表前面所读取的表的列的表达式。

    (4).ref

　　对于每个来自于前面的表的行组合，所有有匹配索引值的行将从这张表中读取。如果联接只使用键的最左边的前缀，或如果键不是UNIQUE

或PRIMARY KEY(换句话说，如果联接不能基于关键字选择单个行的话)，则使用ref。如果使用的键仅仅匹配少量行，该联接类型是不错的。

　　ref可以用于使用=或<=>操作符的带索引的列。


   (5). ref_or_null

　　该联接类型如同ref，但是添加了MySQL可以专门搜索包含NULL值的行。在解决子查询中经常使用该联接类型的优化。


   (6). index_merge

　　该联接类型表示使用了索引合并优化方法。在这种情况下，key列包含了使用的索引的清单，key_len包含了使用的索引的最长的关键元素

。

   (8).index_subquery

　　该联接类型类似于unique_subquery。可以替换IN子查询，但只适合下列形式的子查询中的非唯一索引：

value IN (SELECT key_column FROM single_table WHERE some_expr)


　　(9).range

　　只检索给定范围的行，使用一个索引来选择行。key列显示使用了哪个索引。key_len包含所使用索引的最长关键元素。在该类型中ref列为

NULL。

　　当使用=、<>、>、>=、<、<=、IS NULL、<=>、BETWEEN或者IN操作符，用常量比较关键字列时，可以使用range


    　5.possible_keys

　　possible_keys列指出MySQL能使用哪个索引在该表中找到行。注意，该列完全独立于EXPLAIN输出所示的表的次序。这意味着在

possible_keys中的某些键实际上不能按生成的表次序使用。

　　如果该列是NULL，则没有相关的索引。在这种情况下，可以通过检查WHERE子句看是否它引用某些列或适合索引的列来提高你的查询性能。

如果是这样，创造一个适当的索引并且再次用EXPLAIN检查查询

　　6. key

　　key列显示MySQL实际决定使用的键(索引)。如果没有选择索引，键是NULL。要想强制MySQL使用或忽视possible_keys列中的索引，在查询

中使用FORCE INDEX、USE INDEX或者IGNORE INDEX。

　　7.key_len

　　key_len列显示MySQL决定使用的键长度。如果键是NULL，则长度为NULL。

　　使用的索引的长度。在不损失精确性的情况下，长度越短越好

　　8. ref

　　ref列显示使用哪个列或常数与key一起从表中选择行。

　　9. rows

　　rows列显示MySQL认为它执行查询时必须检查的行数。

　　10. Extra

　　该列包含MySQL解决查询的详细信息,下面详细.

　　(1).Distinct

　　一旦MYSQL找到了与行相联合匹配的行，就不再搜索了

　　(2).Not exists

　　MYSQL优化了LEFT JOIN，一旦它找到了匹配LEFT JOIN标准的行，

　　就不再搜索了

　　(3).Range checked for each

　　Record(index map:#)

　　没有找到理想的索引，因此对于从前面表中来的每一个行组合，MYSQL检查使用哪个索引，并用它来从表中返回行。这是使用索引的最慢的

连接之一

　　(4).Using filesort

　　看到这个的时候，查询就需要优化了。MYSQL需要进行额外的步骤来发现如何对返回的行排序。它根据连接类型以及存储排序键值和匹配条

件的全部行的行指针来排序全部行

　　(5).Using index

　　列数据是从仅仅使用了索引中的信息而没有读取实际的行动的表返回的，这发生在对表的全部的请求列都是同一个索引的部分的时候

　　(6).Using temporary

　　看到这个的时候，查询需要优化了。这里，MYSQL需要创建一个临时表来存储结果，这通常发生在对不同的列集进行ORDER BY上，而不是

GROUP BY上

　　(7).Using where

　　使用了WHERE从句来限制哪些行将与下一张表匹配或者是返回给用户。如果不想返回表中的全部行，并且连接类型ALL或index，这就会发生

，或者是查询有问题

    
