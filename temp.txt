
------------------------------------
release版本管理
Jenkins

项目管理，bug追踪
Redmine

------------------------------------
process.nextTick 是将异步回调放到当前帧的末尾、io回调之前，如果nextTick过多，会导致io回调不断延后,最后callback堆积太多.
setImmediate 是将异步回调放到下一帧,不影响io回调,不会造成callback 堆积.

------------------------------------
如何用 svn 管理 unity3d 项目
CSDN | 2012-11-19 15:16
因为svn用惯了， asset server还是收费的，所以这个版本还是使用svn来管理unity3d的工程，刚开始的时候各种问题，丢失场景啊，丢失纹理贴图等等。被折腾了好久，我终于抽时间去官网上看了下，并且按照官网设置，用了几个月，感觉很稳定，所以存档记录，并分享给大家。
1、在Uniyt里面， Edit->project settings->editor 里面选择metafile(Visible Meta Files)
2、提交的时候仅提交Assets 和 ProjectSettings 两个目录下所有东西，忽略掉其他所有目录和文件
3、提交的时候.metafile也要提交
4、修改了prefab或者场景，一定记得要File -> Save Scene再提交，否则会丢东西

------------------------------------
典型内存泄露
var express = require('express');

function external(cb) {
    process.nextTick(function () {
        throw new Error();
        cb.call(null, 'sunny');
    })
}

var app = express();
app.get('/weather', function (req, res) {
    external(function (data) {
        res.end('Weather of Beijing is ' + data);
    })
})
app.listen(8018);

function noop(){}
process.on('uncaughtException', noop)


------------------------------------
javascrpt == === 比较
http://www.ecma-international.org/ecma-262/5.1/#sec-11.9.3

'' == '0'           // false
0 == ''             // true
0 == '0'            // true

false == 'false'    // false
false == '0'        // true

false == undefined  // false
false == null       // false
null == undefined   // true

' \t\r\n ' == 0     // true
The lack of transitivity is alarming. My advice is to never use the evil twins. Instead, always use === and !==. All of the comparisons just shown produce false with the === operator.
Update:

A good point was brought up by @Casebash in the comments and in @Phillipe Laybaert's answer concerning reference types. For reference types == and === act consistently with one another (except in a special case).

var a = [1,2,3];
var b = [1,2,3];

var c = { x: 1, y: 2 };
var d = { x: 1, y: 2 };

var e = "text";
var f = "te" + "xt";

a == b            // false
a === b           // false

c == d            // false
c === d           // false

e == f            // true
e === f           // true
The special case is when you compare a literal with an object that evaluates to the same literal, 
due to its toString or valueOf method. For example, 
consider the comparison of a string literal with a string object created by the String constructor.

"abc" == new String("abc")    // true
"abc" === new String("abc")   // false
Here the == operator is checking the values of the two objects and returning true, 
but the === is seeing that they're not the same type and returning false. 
Which one is correct? That really depends on what you're trying to compare. 
My advice is to bypass the question entirely and just don't use the String constructor to create string objects.








